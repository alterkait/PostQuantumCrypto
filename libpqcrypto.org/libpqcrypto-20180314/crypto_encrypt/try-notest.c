/*
 * crypto_encrypt/try-notest.c version 20180223
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen-notest.py; do not edit.
 */

#include "crypto_encrypt.h"
#include "try.h"
#include "randombytes.h"

const char *primitiveimplementation = crypto_encrypt_implementation;

#define TUNE_BYTES 1536
#ifdef SMALL
#define MAXTEST_BYTES 128
#else
#define MAXTEST_BYTES 4096
#endif
#ifdef SMALL
#define LOOPS 8
#else
#define LOOPS 64
#endif

static unsigned char *p;
static unsigned char *s;
static unsigned char *m;
static unsigned char *c;
static unsigned char *t;
static unsigned char *p2;
static unsigned char *s2;
static unsigned char *m2;
static unsigned char *c2;
static unsigned char *t2;
#define plen crypto_encrypt_PUBLICKEYBYTES
#define slen crypto_encrypt_SECRETKEYBYTES
unsigned long long mlen;
unsigned long long clen;
unsigned long long tlen;

void preallocate(void)
{
#ifdef RAND_R_PRNG_NOT_SEEDED
  RAND_status();
#endif
}

void allocate(void)
{
  unsigned long long alloclen = 0;
  if (alloclen < TUNE_BYTES) alloclen = TUNE_BYTES;
  if (alloclen < MAXTEST_BYTES + crypto_encrypt_BYTES) alloclen = MAXTEST_BYTES + crypto_encrypt_BYTES;
  if (alloclen < crypto_encrypt_PUBLICKEYBYTES) alloclen = crypto_encrypt_PUBLICKEYBYTES;
  if (alloclen < crypto_encrypt_SECRETKEYBYTES) alloclen = crypto_encrypt_SECRETKEYBYTES;
  p = alignedcalloc(alloclen);
  s = alignedcalloc(alloclen);
  m = alignedcalloc(alloclen);
  c = alignedcalloc(alloclen);
  t = alignedcalloc(alloclen);
  p2 = alignedcalloc(alloclen);
  s2 = alignedcalloc(alloclen);
  m2 = alignedcalloc(alloclen);
  c2 = alignedcalloc(alloclen);
  t2 = alignedcalloc(alloclen);
}

void predoit(void)
{
  crypto_encrypt_keypair(p,s);
  mlen = TUNE_BYTES;
  clen = 0;
  randombytes(m,mlen);
}

void doit(void)
{
  crypto_encrypt(c,&clen,m,mlen,p);
  crypto_encrypt_open(t,&tlen,c,clen,s);
}
